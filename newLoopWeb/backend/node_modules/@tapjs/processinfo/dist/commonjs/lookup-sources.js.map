{"version":3,"file":"lookup-sources.js","sourceRoot":"","sources":["../../src/lookup-sources.ts"],"names":[],"mappings":";AAAA,0EAA0E;AAC1E,2EAA2E;AAC3E,yEAAyE;AACzE,sBAAsB;AACtB,EAAE;AACF,uEAAuE;AACvE,uEAAuE;AACvE,gEAAgE;AAChE,EAAE;AACF,oEAAoE;AACpE,sEAAsE;AACtE,wEAAwE;AACxE,qEAAqE;AACrE,uEAAuE;AACvE,0EAA0E;AAC1E,oDAAoD;;;AAEpD,uEAA6D;AAE7D,mDAAmD;AACnD,MAAM,OAAO,GAAG,IAAI,GAAG,EAAU,CAAA;AACpB,QAAA,YAAY,GAAG,IAAI,GAAG,EAAoB,CAAA;AAEhD,MAAM,qBAAqB,GAAG,GAAG,EAAE;IACxC,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE;QACzB,MAAM,EAAE,GAAG,IAAA,2CAAiB,EAAC,GAAG,CAAC,CAAA;QACjC,IAAI,EAAE,KAAK,KAAK,EAAE;YAChB,sEAAsE;YACtE,mEAAmE;YACnE,mDAAmD;YACnD,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;SACpB;aAAM;YACL,MAAM,OAAO,GAAG,EAAE,EAAE,OAAO,EAAE,OAAO,CAAA;YACpC,IAAI,OAAO,EAAE;gBACX,oBAAY,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;gBAC9B,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;aACpB;SACF;KACF;AACH,CAAC,CAAA;AAhBY,QAAA,qBAAqB,yBAgBjC;AAEM,MAAM,aAAa,GAAG,CAAC,GAAW,EAAE,EAAE,CAAC,IAAA,kBAAU,GAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;AAAtD,QAAA,aAAa,iBAAyC;AAE5D,MAAM,UAAU,GAAG,GAAG,EAAE;IAC7B,IAAI,OAAO,CAAC,IAAI;QAAE,IAAA,6BAAqB,GAAE,CAAA;IACzC,OAAO,oBAAY,CAAA;AACrB,CAAC,CAAA;AAHY,QAAA,UAAU,cAGtB;AAEM,MAAM,kBAAkB,GAAG,CAAC,GAAW,EAAE,EAAE;IAChD,IAAI,CAAC,oBAAY,CAAC,GAAG,CAAC,GAAG,CAAC;QAAE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;IAC5C,IAAA,6BAAqB,GAAE,CAAA;AACzB,CAAC,CAAA;AAHY,QAAA,kBAAkB,sBAG9B","sourcesContent":["// For some reason that is very mysterious as of the time of writing this,\n// node sporadically will in rare cases hang and fail to gracefully exit if\n// a sufficiently large number of findSourceMap calls are made during the\n// process exit event.\n//\n// However, we cannot look up source maps until *after* the module load\n// event is completely finished and the module is about to be executed,\n// because that is when the source map is added to node's cache.\n//\n// To work around this, every time a module is loaded, we attempt to\n// determine whether it likely has the magic sourceMappingURL comment.\n// If so, then we put it in a list, and at each message, attempt to load\n// the sources for all modules in the list. Then, on process exit, if\n// there's anything still pending that likely has a source map, we only\n// have to look up at most one module (ie, if the last module loaded had a\n// source map), which seems to not trigger the hang.\n\nimport { findSourceMapSafe } from './find-source-map-safe.js'\n\n// the list of modules that likely have source maps\nconst maybeSM = new Set<string>()\nexport const sourcesCache = new Map<string, string[]>()\n\nexport const loadPendingSourceMaps = () => {\n  for (const url of maybeSM) {\n    const sm = findSourceMapSafe(url)\n    if (sm === false) {\n      // can only happen if node found the SM comment, and tried to load it,\n      // but got an error creating the sourcemap, because it's invalid or\n      // the file is not present. No need to keep trying.\n      maybeSM.delete(url)\n    } else {\n      const sources = sm?.payload?.sources\n      if (sources) {\n        sourcesCache.set(url, sources)\n        maybeSM.delete(url)\n      }\n    }\n  }\n}\n\nexport const lookupSources = (url: string) => getSources().get(url)\n\nexport const getSources = () => {\n  if (maybeSM.size) loadPendingSourceMaps()\n  return sourcesCache\n}\n\nexport const likelyHasSourceMap = (url: string) => {\n  if (!sourcesCache.has(url)) maybeSM.add(url)\n  loadPendingSourceMaps()\n}\n"]}